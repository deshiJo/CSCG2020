# Cryptography

## Intro to Crypto 1

**Challenge**

"This is an introductory challenge for beginners which want to dive into the world of Cryptography. The three stages of this challenge will increase in difficulty. For an introduction to the first challenge visit the authors step by step guide."

For this challenge we get an encrypted message **"message.txt"** and a public key **"pubkey.pem"**

**Solution**

The **"pubkey.pem"**-file is a RSA-public key.
My first idea was to look at the rsa modulus, maybe weak prime numbers were used.

I have used the following commands to extract the modolus N: 

```
HEX_MODULUS=$(openssl rsa -pubin -in pubkey2.pem -modulus | grep 'Modulus=' |  cut -d'=' -f 2)
echo $HEX_MODULUS
```

You can also use **"openssl rsa -inform PEM -pubin -text < pubkey.pem"** and online converters for **"pem to hex"** and **"hex to decimal"**, to get the modulus as a decimal number (https://holtstrom.com/michael/tools/hextopem.php and https://www.rapidtables.com/convert/number/hex-to-decimal.html)

![](writeupfiles/pemfile.png)

We get the following modulus 
**N = 10327849034940138613515485956077213322791085874638285662823764630659653931824178919168344401508423966366637831067655701114352106747323628144645384205073278784870804834942988268503504130770762781798270763453272421050209487483563600870343875197428105079394315585993355808937811229959083289653056248770988647762812998870912510238393368777882358059256678052653963583286245796285737035786447522814310717433588049686223718247661713594680120785280795132759253149754143640871380226770164628599577669124463514838464342769690232097283333816896581904763736283142031118073027496197756777460403007359764250621763279762041468943079**

and the public exponent 
**e = 65537**

The RSA encryption works as follows:
1. chosen two prime p, q we calculate N = p*q
2. We calculate the modulus qhi(N) = (p-1)*(q-1)
3. Now chose 3 <= e < phi(N) and calculate d with 1 = e * d mod phi(N)
4. The public key is now (e,N) and the private key is now (d,N). 
5. ciphertexts c are calulated with: c = plaintext^e mod N
6. decrypt a ciphertext c with: plaintext = c^d mod N 

If we know the modulus phi(N), we can calulate the inverse element of e, which is d. Thus we can calulate the private key if we know phi(N). 

We can take a look at factorDB and find out if we can calculate the prime factors p and q (N = p*q):
And yes we have a result in a second: 

**q = 16584235167731787847013470803061277015678956556694867873072487447887926204573222554710220299137896151698893829263470795092022504576184748229461509022182668168932373990476110465504678644868916760949835108178505407538822880225906663932043264799941076095252059950113859004542443496612744563482124073298940744796576800151123820336528353672466777346414021097764537645521638337450661718385755338513002335497796149161099248732899206255277182670571055097076123763356692547858422108949105868315872104780985522044066316665393121965734834334905254114025888811325924997427587424504748731773056980012499780203906986519558329**

**p = 622751**

Now we are able to calculate the inverse to our exponent **d = e^-1 mod phi(N)** where **phi(N) = (q-1) * (p-1)**.
Knowing **d** allows us to decrypt the given message.txt (d is the unknown part of the private key).
As described above, for decrypting a message we have to calculate: **plaintext = ciphertext^d mod N**
Now if we convert the result into a string we get the flag: **CSCG{factorizing\_the\_key=pr0f1t}**

I have used the following python script to calculate the flag:

```
import gmpy2
#import binascii
import os
import Crypto.Util.number as number

f = open('message.txt', 'r')
cipher = gmpy2.mpz(f.read())
N = 10327849034940138613515485956077213322791085874638285662823764630659653931824178919168344401508423966366637831067655701114352106747323628144645384205073278784870804834942988268503504130770762781798270763453272421050209487483563600870343875197428105079394315585993355808937811229959083289653056248770988647762812998870912510238393368777882358059256678052653963583286245796285737035786447522814310717433588049686223718247661713594680120785280795132759253149754143640871380226770164628599577669124463514838464342769690232097283333816896581904763736283142031118073027496197756777460403007359764250621763279762041468943079 
e = 65537
q = 16584235167731787847013470803061277015678956556694867873072487447887926204573222554710220299137896151698893829263470795092022504576184748229461509022182668168932373990476110465504678644868916760949835108178505407538822880225906663932043264799941076095252059950113859004542443496612744563482124073298940744796576800151123820336528353672466777346414021097764537645521638337450661718385755338513002335497796149161099248732899206255277182670571055097076123763356692547858422108949105868315872104780985522044066316665393121965734834334905254114025888811325924997427587424504748731773056980012499780203906986519558329
p = 622751
phi = (p-1)*(q-1)
d = gmpy2.divm(1,e,phi)

plaintext = gmpy2.powmod(cipher, d, N)
print(number.long_to_bytes(plaintext).decode())
```



## Intro to Crypto 2

**Challenge**

This is an introductory challenge for beginners which want to dive into the world of Cryptography. The three stages of this challenge will increase in difficulty.
I learned my lesson from the mistakes made in the last challenge! Now p and q are huge, I promise!


For this challenge we get an encrypted message **"message.txt"** and a public key **"pubkey.pem"**

**Solution**

The **"pubkey.pem"**-file is a RSA-public key.
This challenge is similar to "Intro to Crypto 1".

I have used the following commands to extract the modolus N: 

```
HEX_MODULUS=$(openssl rsa -pubin -in pubkey2.pem -modulus | grep 'Modulus=' |  cut -d'=' -f 2)
echo $HEX_MODULUS
```

You can also use **"openssl rsa -inform PEM -pubin -text < pubkey.pem"** and online converters for **"pem to hex"** and **"hex to decimal"**, to get the modulus as a decimal number (https://holtstrom.com/michael/tools/hextopem.php and https://www.rapidtables.com/convert/number/hex-to-decimal.html)

We get the following two numbers:

 **N = 11081631875903145989449935723431993312048263659503073501368579288661507666926127398551161494057149306128113773163942639308834214121175806650609216999457699806761832905200688030797211656004392019494461369905299150414106039926917206543955359193966893148964232596310365304968051716316421386564037673515738090636958039103706945349258789436043666088184674948218539196263599899299117746103356732914111330139176914363944699056706536973601851519543254647327613986429683489937828404640743341705415177790924588759219148196121101333618974290049804819348181073769764832469557718828674823915162708288827812462173689965257895702511**
 
 **e = 65537**
 
 The challange description says: “I learned my lesson from the mistakes made in the last challenge! Now p and q are huge, I promise!”. Lets see if this is correct. 
 Again i have asked factorDB ( “http://factordb.com/index.php”) and https://www.alpertron.com.ar/ECM.HTM. And it seems that we have two primes which are relativly close. 

 **p = 105269330176947292996638200435938306898008923026214454261833875185727477089897046111427146733705930821830266909665628457524081078905360676252447567252776868229878866771906188152589974886284283170888631961882151644823439854179072943695999068501018297820499189273623372907923121271707038222250931356234064474919**
 
 **q = 105269330176947292996638200435938306898008923026214454261833875185727477089897046111427146733705930821830266909665628457524081078905360676252447567252776868229878866771906188152589974886284283170888631961882151644823439854179072943695999068501018297820499189273623372907923121271707038222250931356234064574969**

Now we are able to calculate the inverse to our exponent **d = e^-1 mod phi(N)** where **phi(N) = (q-1) * (p-1)**.
Knowing **d** allows us to decrypt the given message.txt (d is the unknown part of the private key).
As described above, for decrypting a message we have to calculate: **plaintext = ciphertext^d mod N**
Now if we convert the result into a string we get the flag: **CSCG{Ok,\_next\_time\_I\_choose\_p\_and\_q\_random...}**

I have used the following python script to calculate the flag:

```
import gmpy2
import os
import Crypto.Util.number as number
f = open('message.txt', 'r')
cipher = gmpy2.mpz(f.read())

N = 11081631875903145989449935723431993312048263659503073501368579288661507666926127398551161494057149306128113773163942639308834214121175806650609216999457699806761832905200688030797211656004392019494461369905299150414106039926917206543955359193966893148964232596310365304968051716316421386564037673515738090636958039103706945349258789436043666088184674948218539196263599899299117746103356732914111330139176914363944699056706536973601851519543254647327613986429683489937828404640743341705415177790924588759219148196121101333618974290049804819348181073769764832469557718828674823915162708288827812462173689965257895702511
print(N)

e = 65537
p = 105269330176947292996638200435938306898008923026214454261833875185727477089897046111427146733705930821830266909665628457524081078905360676252447567252776868229878866771906188152589974886284283170888631961882151644823439854179072943695999068501018297820499189273623372907923121271707038222250931356234064474919
q = 105269330176947292996638200435938306898008923026214454261833875185727477089897046111427146733705930821830266909665628457524081078905360676252447567252776868229878866771906188152589974886284283170888631961882151644823439854179072943695999068501018297820499189273623372907923121271707038222250931356234064574969

assert(p*q == N)
phi = (p-1)*(q-1)
d = gmpy2.divm(1,e,phi)
plaintext = gmpy2.powmod(cipher, d, N)
print(number.long_to_bytes(plaintext))

```




## Intro to Crypto 3

**Challenge**


**Solution**


Flag: 

## RSA Service

**Challenge**


**Solution**


Flag: 


