# Cryptography

## Intro to Crypto 1

**Challenge**

"This is an introductory challenge for beginners which want to dive into the world of Cryptography. The three stages of this challenge will increase in difficulty. For an introduction to the first challenge visit the authors step by step guide."

For this challenge we get an encrypted message **"message.txt"** and a public key **"pubkey.pem"**

**Solution**

The **"pubkey.pem"**-file is a RSA-public key.
My first idea was to look at the rsa modulus, maybe weak prime numbers were used.

I have used the following commands to extract the modolus N: 

```
HEX_MODULUS=$(openssl rsa -pubin -in pubkey2.pem -modulus | grep 'Modulus=' |  cut -d'=' -f 2)
echo $HEX_MODULUS
```

You can also use **"openssl rsa -inform PEM -pubin -text < pubkey.pem"** and online converters for **"pem to hex"** and **"hex to decimal"**, to get the modulus as a decimal number (https://holtstrom.com/michael/tools/hextopem.php and https://www.rapidtables.com/convert/number/hex-to-decimal.html)

![](writeupfiles/pemfile.png)

We get the following modulus **N = **10327849034940138613515485956077213322791085874638285662823764630659653931824178919168344401508423966366637831067655701114352106747323628144645384205073278784870804834942988268503504130770762781798270763453272421050209487483563600870343875197428105079394315585993355808937811229959083289653056248770988647762812998870912510238393368777882358059256678052653963583286245796285737035786447522814310717433588049686223718247661713594680120785280795132759253149754143640871380226770164628599577669124463514838464342769690232097283333816896581904763736283142031118073027496197756777460403007359764250621763279762041468943079**

and the public exponent **e = 65537**

The RSA encryption works as follows:
    - chosen two prime p, q we calculate N = p*q
    - We calculate the modulus qhi(N) = (p-1)*(q-1)
    - Now chose 3 <= e < phi(N) and calculate d with 1 = e * d mod phi(N)
    - The public key is now (e,N) and the private key is now (d,N). 
    - ciphertexts c are calulated with: c = plaintext^e mod N
    - decrypt a ciphertext c with: plaintext = c^d mod N 

If we know the modulus phi(N), we can calulate the inverse element of e, which is d. Thus we can calulate the private key if we know phi(N).

My first step is take a look at factorDB and find out if our modulus is a "weak" number:
And yes we have a result in a second: 
**q = 16584235167731787847013470803061277015678956556694867873072487447887926204573222554710220299137896151698893829263470795092022504576184748229461509022182668168932373990476110465504678644868916760949835108178505407538822880225906663932043264799941076095252059950113859004542443496612744563482124073298940744796576800151123820336528353672466777346414021097764537645521638337450661718385755338513002335497796149161099248732899206255277182670571055097076123763356692547858422108949105868315872104780985522044066316665393121965734834334905254114025888811325924997427587424504748731773056980012499780203906986519558329**
**p = 622751**

Now we are able to calculate the inverse to our exponent **d = e^-1 mod phi(N)** where **phi(N) = (q-1) * (p-1)**.
Knowing **d** allows us to decrypt the given message.txt (d is the unknown part of the private key).
As described above, for decrypting a message we have to calculate: **plaintext = ciphertext^d mod N**
Now if we convert the result into a string we get the flag: **CSCG{factorizing\_the\_key=pr0f1t}**

I have used the following python script to calculate the flag:

```
import gmpy2
#import binascii
import os
import Crypto.Util.number as number

f = open('message.txt', 'r')
cipher = gmpy2.mpz(f.read())
N = 10327849034940138613515485956077213322791085874638285662823764630659653931824178919168344401508423966366637831067655701114352106747323628144645384205073278784870804834942988268503504130770762781798270763453272421050209487483563600870343875197428105079394315585993355808937811229959083289653056248770988647762812998870912510238393368777882358059256678052653963583286245796285737035786447522814310717433588049686223718247661713594680120785280795132759253149754143640871380226770164628599577669124463514838464342769690232097283333816896581904763736283142031118073027496197756777460403007359764250621763279762041468943079 
e = 65537
q = 16584235167731787847013470803061277015678956556694867873072487447887926204573222554710220299137896151698893829263470795092022504576184748229461509022182668168932373990476110465504678644868916760949835108178505407538822880225906663932043264799941076095252059950113859004542443496612744563482124073298940744796576800151123820336528353672466777346414021097764537645521638337450661718385755338513002335497796149161099248732899206255277182670571055097076123763356692547858422108949105868315872104780985522044066316665393121965734834334905254114025888811325924997427587424504748731773056980012499780203906986519558329
p = 622751
phi = (p-1)*(q-1)
d = gmpy2.divm(1,e,phi)

plaintext = gmpy2.powmod(cipher, d, N)
print(number.long_to_bytes(plaintext).decode())
```



## Intro to Crypto 2

**Challenge**


**Solution**


Flag: 

## Intro to Crypto 3

**Challenge**


**Solution**


Flag: 

## RSA Service

**Challenge**


**Solution**


Flag: 


